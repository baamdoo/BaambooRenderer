#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable

#define _CAMERA
#define _MATERIAL
#define _LIGHT
#include "DescriptorCommon.hg"
#include "AtmosphereCommon.hg"

layout(set = 1, binding = 1) uniform sampler2D g_GBuffer0;    // Albedo.rgb + AO.a
layout(set = 1, binding = 2) uniform sampler2D g_GBuffer1;    // Normal.rgb + MaterialID.a
layout(set = 1, binding = 3) uniform sampler2D g_GBuffer2;    // Emissive.rgb
layout(set = 1, binding = 4) uniform sampler2D g_GBuffer3;    // MotionVectors.rg + Roughness.b + Metallic.a
layout(set = 1, binding = 5) uniform sampler2D g_DepthBuffer;
layout(set = 1, binding = 6) uniform sampler3D g_AerialPerspectiveLUT;
layout(set = 1, binding = 7) uniform sampler2D g_CloudScatteringLUT;
layout(set = 1, binding = 8) uniform samplerCube g_SkyboxLUT;

layout(set = 1, binding = 9, rgba16f) writeonly uniform image2D g_OutSceneTexture;

const float MIN_ROUGHNESS = 0.045;

//** Deprecated **//
// Octahedron normal decoding [Reference : https://www.shadertoy.com/view/cljGD1]
// vec3 OctDecode(vec2 f)
// {
//     f = f * 2.0 - 1.0;
// 
//     // https://twitter.com/Stubbesaurus/status/937994790553227264
//     vec3  n = vec3( f.x, f.y, 1.0 - abs( f.x ) - abs( f.y ) );
//     float t = max( -n.z, 0.0 );
// 
//     n.x += n.x >= 0.0 ? -t : t;
//     n.y += n.y >= 0.0 ? -t : t;
//     return normalize(n);
// }

vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a    = roughness * roughness;
    float a2   = a * a;
    float NoH  = max(dot(N, H), 0.0);
    float NoH2 = NoH * NoH;

    float num   = a2;
    float denom = (NoH2 * (a2 - 1.0) + 1.0);
    denom       = PI * denom * denom;

    return num / denom;
}

float GeometrySchlickGGX(float NoV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float num   = NoV;
    float denom = NoV * (1.0 - k) + k;

    return num / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NoL = max(dot(N, L), 0.0);
    float NoV = max(dot(N, V), 0.0);
    float ggx1 = GeometrySchlickGGX(NoL, roughness);
    float ggx2 = GeometrySchlickGGX(NoV, roughness);

    return ggx1 * ggx2;
}

vec3 CalculateBRDF(vec3 N, vec3 V, vec3 L, float metallic, float roughness, vec3 F0, inout vec3 kD)
{
    vec3 H = normalize(V + L);

    float D = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3  F = FresnelSchlick(max(dot(H, V), 0.0), F0);
    
    vec3 kS = F;
    kD  = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    
    vec3  numerator   = D * G * F;
    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + EPSILON;

    return numerator / denominator;
}

float CalculateAttenuation(float distance, float lightRadius)
{
    float distance2 = max(distance * distance, lightRadius * lightRadius);
    return 1.0 / distance2;
}

vec3 ApplyDirectionalLight(DirectionalLight light, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness, vec3 F0)
{
    vec3 L = normalize(vec3(-light.dirX, -light.dirY, -light.dirZ));
    
    vec3 lightColor = vec3(light.colorR, light.colorG, light.colorB);
    if (light.temperatureK > 0.0)
        lightColor *= ColorTemperatureToRGB(light.temperatureK);
    
    vec3 kD;
    vec3 specular = CalculateBRDF(N, V, L, metallic, roughness, F0, kD);
    
    float NoL       = max(dot(N, L), 0.0);
    vec3  luminance = lightColor * light.illuminanceLux * (1.0 / PI);

    return (kD * albedo / PI + specular) * luminance * NoL;
}

vec3 ApplyPointLight(PointLight light, vec3 P, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness, vec3 F0)
{
    vec3  L        = vec3(light.posX, light.posY, light.posZ) - P;
    float distance = length(L);
    
    vec3 lightColor = vec3(light.colorR, light.colorG, light.colorB);
    if (light.temperatureK > 0.0)
        lightColor *= ColorTemperatureToRGB(light.temperatureK);
    
    vec3 R            = reflect(-V, N);
    vec3 centerToRay  = dot(L, R) * R - L;
    vec3 closestPoint = L + centerToRay * clamp(light.radiusM / length(centerToRay), 0.0, 1.0);
    L = normalize(closestPoint);
    
    vec3 kD;
    vec3 specular = CalculateBRDF(N, V, L, metallic, roughness, F0, kD);

    float NoL             = max(dot(N, L), 0.0);
    float luminousIntensity = light.luminousFluxLm / (light.radiusM * light.radiusM * PI_MUL(4.0));
    float attenuation       = CalculateAttenuation(distance, light.radiusM);
    vec3  luminance         = lightColor * luminousIntensity * attenuation;
    
    return (kD * albedo / PI + specular) * luminance * NoL;
}

vec3 ApplySpotLight(SpotLight light, vec3 P, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness, vec3 F0)
{
    vec3 L         = vec3(light.posX, light.posY, light.posZ) - P;
    float distance = length(L);
    L             /= distance;
    
    // cone attenuation
    float cosTheta        = dot(L, normalize(vec3(-light.dirX, -light.dirY, -light.dirZ)));
    float cosThetaInner   = cos(light.innerConeAngleRad);
    float cosThetaOuter   = cos(light.outerConeAngleRad);
    float spotAttenuation = clamp((cosTheta - cosThetaOuter) / (cosThetaInner - cosThetaOuter), 0.0, 1.0);
    
    if (spotAttenuation == 0.0)
        return vec3(0.0);
    
    vec3 lightColor = vec3(light.colorR, light.colorG, light.colorB);
    if (light.temperatureK > 0.0)
        lightColor *= ColorTemperatureToRGB(light.temperatureK);
    
    vec3 kD;
    vec3 specular = CalculateBRDF(N, V, L, metallic, roughness, F0, kD);
    
    float NoL               = max(dot(N, L), 0.0);
    float solidAngle        = PI_MUL(2.0) * (1.0 - cosThetaOuter);
    float luminousIntensity = light.luminousFluxLm / solidAngle;
    float attenuation       = CalculateAttenuation(distance, light.radiusM);
    vec3  luminance         = lightColor * luminousIntensity * attenuation * spotAttenuation;
    
    return (kD * albedo / PI + specular) * luminance * NoL;
}

layout (local_size_x = 16, local_size_y = 16) in;
void main() 
{
    ivec2 imgSize   = imageSize(g_OutSceneTexture);
    ivec2 pixCoords = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;

    vec2  uv        = (vec2(pixCoords) + 0.5) / vec2(imgSize);

    vec4  gbuffer0 = texture(g_GBuffer0, uv);
    vec4  gbuffer1 = texture(g_GBuffer1, uv);
    vec4  gbuffer2 = texture(g_GBuffer2, uv);
    vec4  gbuffer3 = texture(g_GBuffer3, uv);

    vec3  color = vec3(0.0);
    float depth = texture(g_DepthBuffer, uv).r;
    if (depth == 0.0)
    {
        vec3 rayDir = normalize(ReconstructWorldPos(uv, 0.0, g_Camera.mViewProjInv));

        color = texture(g_SkyboxLUT, rayDir).rgb;
    }
    else
    {
        vec3  albedo = gbuffer0.rgb;
        float ao     = gbuffer0.a;

        vec3 N          = gbuffer1.xyz;
        uint materialID = uint(gbuffer1.w * 255.0);
        vec3 emissive   = gbuffer2.rgb;

        float roughness = max(gbuffer3.z, MIN_ROUGHNESS);
        float metallic  = gbuffer3.w;

        vec3 posWORLD = ReconstructWorldPos(uv, depth, g_Camera.mViewProjInv);

        vec3 V  = normalize(posWORLD);
        vec3 F0 = mix(vec3(0.04), albedo, metallic);

        if (materialID != INVALID_INDEX && materialID < 256)
        {
            MaterialData material = g_MaterialBuffer.materials[materialID];
            if (material.ior > 1.0)
            {
                float ior = material.ior;
                float f0  = pow((ior - 1.0) / (ior + 1.0), 2.0);
                F0        = vec3(f0);
            }
        }

        vec3 Lo = vec3(0.0);
        for (uint i = 0; i < g_LightBuffer.lightingData.numDirectionals; ++i)
        {
            Lo += ApplyDirectionalLight(g_LightBuffer.lightingData.directionals[i], N, V, albedo, metallic, roughness, F0);
        }
        
        for (uint i = 0; i < g_LightBuffer.lightingData.numPoints; ++i)
        {
            Lo += ApplyPointLight(g_LightBuffer.lightingData.points[i], posWORLD, N, V, albedo, metallic, roughness, F0);
        }
        
        for (uint i = 0; i < g_LightBuffer.lightingData.numSpots; ++i)
        {
            Lo += ApplySpotLight(g_LightBuffer.lightingData.spots[i], posWORLD, N, V, albedo, metallic, roughness, F0);
        }

        vec3 ambientColor = vec3(g_LightBuffer.lightingData.ambientColorR, 
                                 g_LightBuffer.lightingData.ambientColorG, 
                                 g_LightBuffer.lightingData.ambientColorB);
        vec3 ambient      = ambientColor * g_LightBuffer.lightingData.ambientIntensity * albedo * ao;

        color = ambient + Lo + emissive;

        // Aerial perspective
        {
            float viewDistance = max(0.0, length(posWORLD));

            ivec3 texSize = textureSize(g_AerialPerspectiveLUT, 0);
            float slice   = viewDistance * (1.0 / AP_KM_PER_SLICE) * DISTANCE_SCALE;
            float w       = sqrt(slice / float(texSize.z));
                  slice   = w * texSize.z;

            vec4 ap = texture(g_AerialPerspectiveLUT, vec3(uv, w));

            // prevents an abrupt appearance of fog on objects close to the camera
            float weight = 1.0;
            if (slice < sqrt(0.5))
            {
                weight = clamp((slice * slice * 2.0), 0.0, 1.0); 
            }
            ap.rgb *= weight;
            ap.a    = 1.0 - weight * (1.0 - ap.a);

            // FinalColor = (SurfaceColor * Transmittance) + InScatteredLight
            color = color * ap.a + ap.rgb;
        }
    }

    // Cloud
    {
        vec4 cloud = texture(g_CloudScatteringLUT, uv);

        color = color * cloud.a + cloud.rgb;
    }
    
    imageStore(g_OutSceneTexture, pixCoords, vec4(color, 1.0));
}