#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "Common.hg"
#include "HelperFunctions.hg"
#include "Noise.hg"

layout(set = SET_PUSH, binding = 0, rgba16f) writeonly uniform image3D g_BaseNoise;

layout(push_constant) uniform PushConstants
{
    // Perlin
    float fPerlin;
    uint  octaves;
    float persistence;
    float lacunarityPerlin;

    // Worley
    float fWorley;
    float lacunarityWorley;

    // misc
    float time_s;
} g_Push;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main() 
{
    ivec3 imgSize   = imageSize(g_BaseNoise);
    ivec3 pixCoords = ivec3(gl_GlobalInvocationID.xyz);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;
    
    vec3  uvw       = vec3(pixCoords + 0.5) / vec3(imgSize);
          uvw.xy   += g_Push.time_s * 0.02;

    // float noise = remap(perlinNoise3D(uvw * 10.0), -1.0, 1.0, 0.0, 1.0);
    // float noise = ridgedFBM(uvw * 10.0, 4, 0.5, 2.0);
    // float noise = turbulenceFBM(uvw * 10.0, 4, 0.5, 2.0);
    // float noise = worleyNoise3D(uvw, 10.0);
    // float noise = 1.0 - worleyNoise3D(uvw, 10.0);
    // float noise = perlinWorley3D(uvw, 10.0);
    // noise = steppedNoise(noise);
    
    float perlin       = perlinFBM(uvw, g_Push.fPerlin, int(g_Push.octaves), g_Push.persistence, g_Push.lacunarityPerlin);
          perlin       = perlin * 0.5 + 0.5;
    float worley0      = worleyFBM(uvw, g_Push.fWorley);
    float worley1      = worleyFBM(uvw, g_Push.fWorley * g_Push.lacunarityWorley);
    float worley2      = worleyFBM(uvw, g_Push.fWorley * g_Push.lacunarityWorley * g_Push.lacunarityWorley);
    float perlinWorley = remap(perlin, 0.0, 1.0, worley0, 1.0);

    vec4 value = vec4(perlinWorley, worley0, worley1, worley2);

    imageStore(g_BaseNoise, pixCoords, value);
}