#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "Common.hg"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = SET_PUSH, binding = 0) uniform sampler2D g_SceneTexture;

layout(set = SET_PUSH, binding = 1, rgba8) uniform writeonly image2D g_OutputImage;

// Push constants
layout(push_constant) uniform PushConstants
{
    uint  tonemapOperator; // 0: Reinhard, 1: ACES, 2: Uncharted2
    float ev100;
    float gamma;
} g_Push;

vec3 ACESFilm(vec3 x)
{
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;

    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

vec3 Uncharted2Tonemap(vec3 x)
{
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

void main()
{
    ivec2 pixCoords = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixCoords, imageSize(g_OutputImage))))
        return;

    vec2 uv       = (vec2(pixCoords) + 0.5) / vec2(imageSize(g_OutputImage));
    vec3 hdrColor = texture(g_SceneTexture, uv).rgb;

    // exposure correction
    float ev100    = g_Push.ev100;
    float exposure = 1.0 / pow(2.0, ev100);
    hdrColor *= exposure;
    
    vec3 toneMapped;
    switch(g_Push.tonemapOperator)
    {
        case 0: // Reinhard
            toneMapped = hdrColor / (1.0 + hdrColor);
            break;
            
        case 1: // ACES
            toneMapped = ACESFilm(hdrColor);
            break;
            
        case 2: // Uncharted2
            const float W = 11.2;

            vec3 curr       = Uncharted2Tonemap(hdrColor);
            vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));

            toneMapped = curr * whiteScale;
            break;
            
        default:
            toneMapped = hdrColor;
            break;
    }
    
    vec3 gammaCorrected = pow(toneMapped, vec3(1.0 / g_Push.gamma));
    
    imageStore(g_OutputImage, pixCoords, vec4(gammaCorrected, 1.0));
}