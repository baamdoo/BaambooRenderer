#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : require

#define _SCENEENVIRONMENT
#include "AtmosphereCommon.hg"

layout(set = 1, binding = 2, r11f_g11f_b10f) uniform writeonly image2D g_OutTransmittanceLUT;

void GenerateTransmittanceCoordsFromUV(vec2 uv, float bottomRadius, float topRadius, out float cosZenithAngle, out float viewHeight)
{
    // Put more frequencies near the horizon
    float H    = safeSqrt(topRadius * topRadius - bottomRadius * bottomRadius);
    float rho  = H * uv.y;
    viewHeight = safeSqrt(rho * rho + bottomRadius * bottomRadius);

    float d_min = topRadius - viewHeight;
    float d_max = rho + H;
    float d     = mix(d_min, d_max, uv.x);

    cosZenithAngle = d == 0.0 ? 
        1.0 : (H * H - rho * rho - d * d) / (2.0 * viewHeight * d);
    cosZenithAngle = clamp(cosZenithAngle, -1.0, 1.0);
}

vec3 ComputeExtinction(vec3 rayOrigin, vec3 rayDir, float rayLength, int numSamples) 
{
    AtmosphereData Atmosphere = GetAtmosphereData();

    float stepSize   = rayLength / float(numSamples);
    vec3  extinction = vec3(0.0);
    
    for (int i = 0; i < numSamples; ++i) 
    {
        float t   = (float(i) + 0.5) * stepSize;
        vec3  pos = rayOrigin + t * rayDir;

        float altitude = GetAltitude(pos, Atmosphere.planetRadiusKm);
        
        float rayleighDensity = GetDensityAtHeight(altitude, Atmosphere.rayleighDensityKm);
        extinction += Atmosphere.rayleighScattering * rayleighDensity * stepSize;
        
        float mieDensity = GetDensityAtHeight(altitude, Atmosphere.mieDensityKm);
        extinction += (Atmosphere.mieScattering + Atmosphere.mieAbsorption) * mieDensity * stepSize;
        
        float ozoneDensity = GetDensityOzoneAtHeight(altitude, Atmosphere.ozoneCenterKm, Atmosphere.ozoneWidthKm);
        extinction += Atmosphere.ozoneAbsorption * ozoneDensity * stepSize;
    }
    
    return extinction;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main() 
{
    ivec2 imgSize   = imageSize(g_OutTransmittanceLUT);
    ivec2 pixCoords = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;

    vec2  uv        = (vec2(pixCoords) + 0.5) / vec2(imgSize);
    
    AtmosphereData Atmosphere = GetAtmosphereData();

    float cosZenithAngle, viewHeight;
    GenerateTransmittanceCoordsFromUV(
        uv, Atmosphere.planetRadiusKm, Atmosphere.atmosphereRadiusKm, cosZenithAngle, viewHeight
    );
    
    vec3 rayOrigin = vec3(0.0, viewHeight, 0.0);
    vec3 rayDir    = vec3(safeSqrt(1.0 - cosZenithAngle * cosZenithAngle), cosZenithAngle, 0.0);
    
    vec2 groundIntersection     = RaySphereIntersection(rayOrigin, rayDir, PLANET_CENTER, Atmosphere.planetRadiusKm);
    vec2 atmosphereIntersection = RaySphereIntersection(rayOrigin, rayDir, PLANET_CENTER, Atmosphere.atmosphereRadiusKm);
    
    float rayLength;
    if (groundIntersection.x > 0.0) 
    {
        // ray hits ground
        rayLength = groundIntersection.x;
    } else 
    {
        // ray goes through atmosphere
        rayLength = atmosphereIntersection.y;
    }
    
    if (rayLength <= 0.0) 
    {
        imageStore(g_OutTransmittanceLUT, ivec2(uv), vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }
    
    const int numSamples = 64;
    vec3 extinction    = ComputeExtinction(rayOrigin, rayDir, rayLength, numSamples);
    vec3 transmittance = exp(-extinction); // (2) T(xa,xb) = exp(−Integral(xa~xb, σ(x)dx))
    
    imageStore(g_OutTransmittanceLUT, pixCoords, vec4(transmittance, 1.0));
}