#ifndef _GLSL_NOISE_HEADER
#define _GLSL_NOISE_HEADER

#extension GL_GOOGLE_include_directive: require

#define _GLSL
#include "../Common.bsh"

vec2 fade(vec2 t) 
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

vec3 fade(vec3 t) 
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

//////////////////////////////////////////////////////
// Reference: https://www.shadertoy.com/view/3dVXDc //
#define UI0 1597334673U
#define UI1 3812015801U
#define UI2 uvec2(UI0, UI1)
#define UI3 uvec3(UI0, UI1, 2798796415U)
#define UIF (1.0 / float(0xffffffffU))

float hash1D(vec3 p) 
{
    p  = fract(p * 1031.1031);
    p += dot(p, p.yzx + 19.19);
    return fract((p.x + p.y) * p.z);
}

vec2 hash2D(vec2 p) 
{
    uvec2 q = uvec2(ivec2(p)) * UI2;
	      q = (q.x ^ q.y) * UI2;

	return -1.0 + 2.0 * vec2(q) * UIF;
}

vec3 hash3D(vec3 p) 
{
    uvec3 q = uvec3(ivec3(p)) * UI3;
	      q = (q.x ^ q.y ^ q.z) * UI3;

	return -1.0 + 2.0 * vec3(q) * UIF;
}
//////////////////////////////////////////////////////

float perlinNoise2D(vec2 p, float frequency) 
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = fade(f);
    
    float dot00 = dot(hash2D(mod(i + vec2(0.0, 0.0), frequency)), f - vec2(0.0, 0.0));
    float dot10 = dot(hash2D(mod(i + vec2(1.0, 0.0), frequency)), f - vec2(1.0, 0.0));
    float dot01 = dot(hash2D(mod(i + vec2(0.0, 1.0), frequency)), f - vec2(0.0, 1.0));
    float dot11 = dot(hash2D(mod(i + vec2(1.0, 1.0), frequency)), f - vec2(1.0, 1.0));
    
    return mix(mix(dot00, dot10, u.x),
               mix(dot01, dot11, u.x), u.y);
}

float perlinNoise3D(vec3 p, float frequency) 
{
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = fade(f);
    
    float dot000 = dot(hash3D(mod(i + vec3(0,0,0), frequency)), f - vec3(0,0,0));
    float dot001 = dot(hash3D(mod(i + vec3(0,0,1), frequency)), f - vec3(0,0,1));
    float dot010 = dot(hash3D(mod(i + vec3(0,1,0), frequency)), f - vec3(0,1,0));
    float dot100 = dot(hash3D(mod(i + vec3(1,0,0), frequency)), f - vec3(1,0,0));
    float dot011 = dot(hash3D(mod(i + vec3(0,1,1), frequency)), f - vec3(0,1,1));
    float dot101 = dot(hash3D(mod(i + vec3(1,0,1), frequency)), f - vec3(1,0,1));
    float dot110 = dot(hash3D(mod(i + vec3(1,1,0), frequency)), f - vec3(1,1,0));
    float dot111 = dot(hash3D(mod(i + vec3(1,1,1), frequency)), f - vec3(1,1,1));
    
    // trilinear interpolation of 8 corner contributions
    return mix(mix(mix(dot000, dot100, u.x),
                   mix(dot010, dot110, u.x), u.y),
               mix(mix(dot001, dot101, u.x),
                   mix(dot011, dot111, u.x), u.y), u.z);
}

float perlinFBM(vec2 p, float frequency, int octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float normalization = 0.0;
    
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise2D(p * frequency, frequency);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total / normalization;
}

float perlinFBM(vec3 p, float frequency, uint octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float normalization = 0.0;
    
    for (uint i = 0u; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p * frequency, frequency);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total / normalization;
}

float worleyNoise2D(vec2 p, float frequency) 
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    
    float closest = 10000.0;
    for (int x = -1; x <= 1; ++x) 
    {
        for (int y = -1; y <= 1; ++y) 
        {
            {
                vec2 neighbor = i + vec2(x, y);
                vec2 offset   = hash2D(mod(neighbor, vec2(frequency))) * 0.5 + 0.5;

                vec2  d    = f - (vec2(x, y) + offset);
                float dist = dot(d, d);
                closest    = min(closest, dist);
            }
        }
    }
    
    return 1.0 - closest;
}

float worleyNoise3D(vec3 p, float frequency) 
{
    vec3 i = floor(p);
    vec3 f = fract(p);
    
    float closest = 10000.0;
    for (int x = -1; x <= 1; ++x) 
    {
        for (int y = -1; y <= 1; ++y) 
        {
            for (int z = -1; z <= 1; ++z)
            {
                vec3 neighbor = i + vec3(x, y, z);
                vec3 offset   = hash3D(mod(neighbor, vec3(frequency))) * 0.5 + 0.5;

                vec3  d    = f - (vec3(x, y, z) + offset);
                float dist = dot(d, d);
                closest    = min(closest, dist);
            }
        }
    }
    
    return 1.0 - closest;
}

// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes
// chapter in GPU Pro 7.
float worleyFBM(vec2 p, float frequency)
{
    return worleyNoise2D(p * frequency, frequency) * 0.625 +
           worleyNoise2D(p * frequency * 2.0, frequency * 2.0) * 0.25 +
           worleyNoise2D(p * frequency * 4.0, frequency * 4.0) * 0.125;
}

float worleyFBM(vec2 p, float frequency, uint octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float normalization = 0.0;
    
    for (uint i = 0u; i < octaves; i++) 
    {
        float noise = worleyNoise2D(p * frequency, frequency);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total / normalization;
}

float worleyFBM(vec3 p, float frequency)
{
    return worleyNoise3D(p * frequency, frequency) * 0.625 +
           worleyNoise3D(p * frequency * 2.0, frequency * 2.0) * 0.25 +
           worleyNoise3D(p * frequency * 4.0, frequency * 4.0) * 0.125;
}

float worleyFBM(vec3 p, float frequency, uint octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float normalization = 0.0;
    
    for (uint i = 0u; i < octaves; i++) 
    {
        float noise = worleyNoise3D(p * frequency, frequency);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total / normalization;
}

float ridgedFBM(vec3 p, int octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float frequency     = 1.0;
    float normalization = 0.0;
    
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p * frequency, frequency);
        noise       = abs(noise);
        noise       = 1.0 - noise;

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    total /= normalization;
    total *= total;
    
    return total;
}

float turbulenceFBM(vec3 p, int octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float frequency     = 1.0;
    float normalization = 0.0;
    
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p * frequency, frequency);
        noise       = abs(noise);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return total / normalization;
}

vec2 worleyBidirection(vec3 p, float cellCount) 
{
    vec3 i = floor(p * cellCount);
    vec3 f = fract(p * cellCount);
    
    float f1 = 1.0;
    float f2 = 1.0;
    for (int x = -1; x <= 1; ++x) 
    {
        for (int y = -1; y <= 1; ++y) 
        {
            for (int z = -1; z <= 1; ++z)
            {
                vec3 neighbor = i + vec3(x, y, z);
                vec3 offset = hash3D(mod(neighbor, cellCount));
                
                float dist = length(vec3(x, y, z) + offset - f);
                if (dist < f1) 
                {
                    f2 = f1;
                    f1 = dist;
                }
                else if (dist < f2) 
                {
                    f2 = dist;
                }
            }
        }
    }
    
    return vec2(f1, f2);
}

float steppedNoise(float noiseSample)
{
    float steppedSample = floor(noiseSample * 10.0) / 10.0;
    float remainder     = fract(noiseSample * 10.0);

    return (steppedSample - remainder) * 0.5 + 0.5;
}


///////////////////////////////////////////////////////
// Reference : https://www.shadertoy.com/view/NlSGDz //
// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a single unsigned integer.
uint hash1D(uint p, uint seed) 
{
    const uint m = 0x5bd1e995U;
    uint hash = seed;
    // process input
    uint k = p;
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // some final mixing
    hash ^= hash >> 13;
    hash *= m;
    hash ^= hash >> 15;
    return hash;
}

// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a 2-dimensional unsigned integer input vector.
uint hash2D(uvec2 p, uint seed)
{
    const uint m = 0x5bd1e995U;
    uint hash    = seed;
    // process first vector element
    uint k = p.x; 
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // process second vector element
    k = p.y; 
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
	// some final mixing
    hash ^= hash >> 13;
    hash *= m;
    hash ^= hash >> 15;
    return hash;
}

// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a 3-dimensional unsigned integer input vector.
uint hash3D(uvec3 p, uint seed)
{
    const uint m = 0x5bd1e995U;
    uint hash = seed;
    // process first vector element
    uint k = p.x; 
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // process second vector element
    k = p.y; 
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
    // process third vector element
    k = p.z; 
    k *= m;
    k ^= k >> 24;
    k *= m;
    hash *= m;
    hash ^= k;
	// some final mixing
    hash ^= hash >> 13;
    hash *= m;
    hash ^= hash >> 15;
    return hash;
}

vec2 gradientDirection2D(uint hash) 
{
    switch (int(hash) & 3) // look at the last two bits to pick a gradient direction
    { 
    case 0:
        return vec2(1.0, 1.0);
    case 1:
        return vec2(-1.0, 1.0);
    case 2:
        return vec2(1.0, -1.0);
    case 3:
        return vec2(-1.0, -1.0);
    }
}


vec3 gradientDirection3D(uint hash) 
{
    switch (int(hash) & 15) // look at the last four bits to pick a gradient direction
    { 
    case 0:
        return vec3(1, 1, 0);
    case 1:
        return vec3(-1, 1, 0);
    case 2:
        return vec3(1, -1, 0);
    case 3:
        return vec3(-1, -1, 0);
    case 4:
        return vec3(1, 0, 1);
    case 5:
        return vec3(-1, 0, 1);
    case 6:
        return vec3(1, 0, -1);
    case 7:
        return vec3(-1, 0, -1);
    case 8:
        return vec3(0, 1, 1);
    case 9:
        return vec3(0, -1, 1);
    case 10:
        return vec3(0, 1, -1);
    case 11:
        return vec3(0, -1, -1);
    case 12:
        return vec3(1, 1, 0);
    case 13:
        return vec3(-1, 1, 0);
    case 14:
        return vec3(0, -1, 1);
    case 15:
        return vec3(0, -1, -1);
    }
}
///////////////////////////////////////////////////////

float perlinNoise2D(vec2 p, uint seed) 
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = fade(f);
    
    float dot00 = dot(gradientDirection2D(hash2D(uvec2(i) + uvec2(0, 0), seed)), f - vec2(0.0, 0.0));
    float dot10 = dot(gradientDirection2D(hash2D(uvec2(i) + uvec2(1, 0), seed)), f - vec2(1.0, 0.0));
    float dot01 = dot(gradientDirection2D(hash2D(uvec2(i) + uvec2(0, 1), seed)), f - vec2(0.0, 1.0));
    float dot11 = dot(gradientDirection2D(hash2D(uvec2(i) + uvec2(1, 1), seed)), f - vec2(1.0, 1.0));
    
    return mix(mix(dot00, dot10, u.x),
               mix(dot01, dot11, u.x), u.y);
}

float perlinNoise3D(vec3 p, uint seed) 
{
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = fade(f);
    
    float dot000 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(0, 0, 0), seed)), f - vec3(0,0,0));
    float dot001 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(0, 0, 1), seed)), f - vec3(0,0,1));
    float dot010 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(0, 1, 0), seed)), f - vec3(0,1,0));
    float dot100 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(1, 0, 0), seed)), f - vec3(1,0,0));
    float dot011 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(0, 1, 1), seed)), f - vec3(0,1,1));
    float dot101 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(1, 0, 1), seed)), f - vec3(1,0,1));
    float dot110 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(1, 1, 0), seed)), f - vec3(1,1,0));
    float dot111 = dot(gradientDirection3D(hash3D(uvec3(i) + uvec3(1, 1, 1), seed)), f - vec3(1,1,1));
    
    // trilinear interpolation of 8 corner contributions
    return mix(mix(mix(dot000, dot100, u.x),
                   mix(dot010, dot110, u.x), u.y),
               mix(mix(dot001, dot101, u.x),
                   mix(dot011, dot111, u.x), u.y), u.z);
}

float perlinFBM(vec2 p, float frequency, int octaves, float persistence, float lacunarity, uint seed) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    
    uint curSeed = seed;
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise2D(p * frequency, curSeed);

        total  += noise * amplitude;
        curSeed = hash1D(curSeed, 0x0u); // create a new seed for each octave

        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total;
}

float perlinFBM(vec3 p, float frequency, uint octaves, float persistence, float lacunarity, uint seed) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    
    uint curSeed = seed;
    for (uint i = 0u; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p * frequency, curSeed);

        total  += noise * amplitude;
        curSeed = hash1D(curSeed, 0x0u); // create a new seed for each octave

        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total;
}

#endif // _GLSL_NOISE_HEADER