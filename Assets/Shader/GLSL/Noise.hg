#ifndef _GLSL_NOISE_HEADER
#define _GLSL_NOISE_HEADER

#extension GL_GOOGLE_include_directive: require

#define _GLSL
#include "../Common.bsh"

vec3 hash3D(vec3 p) 
{
    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 74.7)),
                          dot(p, vec3(269.5, 183.3, 246.1)),
                          dot(p, vec3(113.5, 271.9, 124.6)))) * 43758.5453);
}

vec3 fade(vec3 t) 
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlinNoise3D(vec3 p, float period) 
{
    vec3 i = floor(p * period);
    vec3 f = fract(p * period);
    vec3 u = fade(f);
    
    float dot000 = dot(hash3D(i + vec3(0,0,0)) * 2.0 - 1.0, f - vec3(0,0,0));
    float dot100 = dot(hash3D(i + vec3(1,0,0)) * 2.0 - 1.0, f - vec3(1,0,0));
    float dot010 = dot(hash3D(i + vec3(0,1,0)) * 2.0 - 1.0, f - vec3(0,1,0));
    float dot110 = dot(hash3D(i + vec3(1,1,0)) * 2.0 - 1.0, f - vec3(1,1,0));
    float dot001 = dot(hash3D(i + vec3(0,0,1)) * 2.0 - 1.0, f - vec3(0,0,1));
    float dot101 = dot(hash3D(i + vec3(1,0,1)) * 2.0 - 1.0, f - vec3(1,0,1));
    float dot011 = dot(hash3D(i + vec3(0,1,1)) * 2.0 - 1.0, f - vec3(0,1,1));
    float dot111 = dot(hash3D(i + vec3(1,1,1)) * 2.0 - 1.0, f - vec3(1,1,1));
    
    // trilinear interpolation of 8 corner contributions
    return mix(mix(mix(dot000, dot100, u.x),
                   mix(dot010, dot110, u.x), u.y),
               mix(mix(dot001, dot101, u.x),
                   mix(dot011, dot111, u.x), u.y), u.z);
}

float worleyNoise3D(vec3 p, float cellCount) 
{
    vec3 i = floor(p * cellCount);
    vec3 f = fract(p * cellCount);
    
    float closest = 1.0;
    for (int x = -1; x <= 1; ++x) 
    {
        for (int y = -1; y <= 1; ++y) 
        {
            for (int z = -1; z <= 1; ++z)
            {
                vec3 neighbor = i + vec3(x, y, z);
                vec3 offset   = hash3D(mod(neighbor, cellCount));
                
                float dist = length(vec3(x, y, z) + offset - f);
                closest    = min(closest, dist);
            }
        }
    }
    
    return closest;
}

float fbm(vec3 p, int octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float frequency     = 1.0;
    float normalization = 0.0;
    
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p, frequency);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return total / normalization;
}

float ridgedFBM(vec3 p, int octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float frequency     = 1.0;
    float normalization = 0.0;
    
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p, frequency);
        noise       = abs(noise);
        noise       = 1.0 - noise;

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    total /= normalization;
    total *= total;
    
    return total;
}

float turbulenceFBM(vec3 p, int octaves, float persistence, float lacunarity) 
{
    float total         = 0.0;
    float amplitude     = 1.0;
    float frequency     = 1.0;
    float normalization = 0.0;
    
    for (int i = 0; i < octaves; i++) 
    {
        float noise = perlinNoise3D(p, frequency);
        noise       = abs(noise);

        total         += noise * amplitude;
        normalization += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return total / normalization;
}

float steppedNoise(float noiseSample)
{
    float steppedSample = floor(noiseSample * 10.0) / 10.0;
    float remainder     = fract(noiseSample * 10.0);

    return (steppedSample - remainder) * 0.5 + 0.5;
}

#endif // _GLSL_HELPER_FUNCTION_HEADER