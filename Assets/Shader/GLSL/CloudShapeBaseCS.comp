#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "NoiseCommon.hg"
#include "HelperFunctions.hg"

layout(set = 1, binding = 0, rgba16f) writeonly uniform image3D g_OutBaseNoise;

layout(push_constant) uniform PushConstants
{
    // r-channel
    float rFrequency;
    uint  rOctaves;
    float rPersistence;
    float rLacunarity;

    // g-channel
    float gFrequency;
    uint  gOctaves;
    float gPersistence;
    float gLacunarity;

    // b-channel
    float bFrequency;
    uint  bOctaves;
    float bPersistence;
    float bLacunarity;

    // blend
    float wPerlin;
    float wWorley;
} g_Push;

// Reference: https://www.shadertoy.com/view/3dVXDc

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main() 
{
    ivec3 imgSize   = imageSize(g_OutBaseNoise);
    ivec3 pixCoords = ivec3(gl_GlobalInvocationID.xyz);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;
    
    vec3  uvw       = vec3(pixCoords + 0.5) / vec3(imgSize);

    // float noise = remap(perlinNoise3D(uvw * 10.0), -1.0, 1.0, 0.0, 1.0);
    // float noise = ridgedFBM(uvw * 10.0, 4, 0.5, 2.0);
    // float noise = turbulenceFBM(uvw * 10.0, 4, 0.5, 2.0);
    // float noise = worleyNoise3D(uvw, 10.0);
    // float noise = 1.0 - worleyNoise3D(uvw, 10.0);
    // float noise = perlinWorley3D(uvw, 10.0);
    // noise = steppedNoise(noise);
    
    // uint seed = 1u;
    float perlin       = perlinFBM(uvw, 8.0, 7, exp(-0.85), 2.0);
          perlin       = mix(1.0, perlin, 0.5);
          perlin       = abs(perlin * 2.0 - 1.0);
          //perlin       = (perlin + 1.0) * 0.5;
    float worley0      = worleyFBM(uvw, 4.0);
    float worley1      = worleyFBM(uvw, 8.0);
    float worley2      = worleyFBM(uvw, 16.0);
    float worley3      = worleyFBM(uvw, 32.0);
    float perlinWorley = remap(perlin, worley0 - 1.0, 1.0, 0.0, 1.0);

    vec4 value = vec4(perlinWorley, worley1, worley2, worley3);

    imageStore(g_OutBaseNoise, pixCoords, value);
}