#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : require
#include "../Common.bsh"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = SET_PUSH, binding = 0) uniform sampler2D g_SceneTexture;
layout (set = SET_PUSH, binding = 1) uniform sampler2D g_VelocityTexture; // MotionVectors.xy + Roughness.z + Metallic.w
layout (set = SET_PUSH, binding = 2) uniform sampler2D g_HistoryTexture;

layout (set = SET_PUSH, binding = 3, rgba16f) uniform writeonly image2D g_OutputImage;

layout(push_constant) uniform PushConstants
{
    float blendFactor;
    uint  bFirstFrame;
} g_Push;

// Convert RGB to YCoCg color space for better neighborhood clamping
vec3 RGB2YCoCg(vec3 rgb)
{
    float Y  = dot(rgb, vec3(0.25, 0.5, 0.25));
    float Co = dot(rgb, vec3(0.5, 0.0, -0.5));
    float Cg = dot(rgb, vec3(-0.25, 0.5, -0.25));

    return vec3(Y, Co, Cg);
}

vec3 YCoCg2RGB(vec3 ycocg)
{
    float Y  = ycocg.x;
    float Co = ycocg.y;
    float Cg = ycocg.z;
    
    float R = Y + Co - Cg;
    float G = Y + Cg;
    float B = Y - Co - Cg;
    
    return vec3(R, G, B);
}

// Reference: https://www.shadertoy.com/view/MtVGWz
vec4 TextureCatmullRom(sampler2D tex, vec2 uv, vec2 texSize)
{
    vec2 samplePos = uv * texSize;
    vec2 texPos1   = floor(samplePos - 0.5) + 0.5;
    
    vec2 f  = samplePos - texPos1;
    vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));
    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);
    vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));
    vec2 w3 = f * f * (-0.5 + 0.5 * f);
    
    vec2 w12      = w1 + w2;
    vec2 offset12 = w2 / (w1 + w2);
    
    vec2 texPos0  = texPos1 - 1.0;
    vec2 texPos3  = texPos1 + 2.0;
    vec2 texPos12 = texPos1 + offset12;
    
    texPos0  /= texSize;
    texPos3  /= texSize;
    texPos12 /= texSize;
    
    vec4 result = vec4(0.0);
    result += texture(tex, vec2(texPos0.x, texPos0.y)) * w0.x * w0.y;
    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;
    result += texture(tex, vec2(texPos3.x, texPos0.y)) * w3.x * w0.y;
    
    result += texture(tex, vec2(texPos0.x, texPos12.y)) * w0.x * w12.y;
    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;
    result += texture(tex, vec2(texPos3.x, texPos12.y)) * w3.x * w12.y;
    
    result += texture(tex, vec2(texPos0.x, texPos3.y)) * w0.x * w3.y;
    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;
    result += texture(tex, vec2(texPos3.x, texPos3.y)) * w3.x * w3.y;
    
    return result;
}

// Variance clipping for better ghosting reduction
vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 history, vec3 current)
{
    vec3 center  = 0.5 * (aabbMax + aabbMin);
    vec3 extents = 0.5 * (aabbMax - aabbMin);
    
    vec3  v_clip  = history - center;
    vec3  v_unit  = v_clip / extents;
    vec3  a_unit  = abs(v_unit);
    float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));
    
    if (ma_unit > 1.0)
        return center + v_clip / ma_unit;
    else
        return history;
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 texSize    = textureSize(g_SceneTexture, 0);
    if (any(greaterThanEqual(pixelCoord, texSize)))
        return;

    vec2  uv         = vec2(pixelCoord + 0.5) / vec2(texSize);

    vec2 velocity      = texture(g_VelocityTexture, uv).xy;
    vec2 historyUV     = uv - velocity;
    bool bValidHistory = all(greaterThanEqual(historyUV, vec2(0.0))) && all(lessThanEqual(historyUV, vec2(1.0)));

    vec3 currentColor = texture(g_SceneTexture, uv).rgb;
    vec3 historyColor = vec3(0.0);
    if (bValidHistory && g_Push.bFirstFrame == 0)
    {
        historyColor = TextureCatmullRom(g_HistoryTexture, historyUV, texSize).rgb;
    }
    else
    {
        historyColor = currentColor;
    }

    // neighborhood clamping in YCoCg space
    vec3 currentYCoCg = RGB2YCoCg(currentColor);
    vec3 historyYCoCg = RGB2YCoCg(historyColor);

    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);
    vec3 neighborMin = vec3(1e10);
    vec3 neighborMax = vec3(-1e10);
    
    // sample a 3x3 neighborhood around the current pixel
    for (float x = -1.0; x <= 1.0; x += 1.0) 
    {
        for (float y = -1.0; y <= 1.0; y += 1.0) 
        {
            vec2 sampleUV      = uv + vec2(x, y) / texSize;
            vec3 neighborColor = texture(g_SceneTexture, sampleUV).rgb;
            vec3 neighborYCoCg = RGB2YCoCg(neighborColor);

            m1 += neighborYCoCg;
            m2 += neighborYCoCg * neighborYCoCg;
            neighborMin = min(neighborMin, neighborYCoCg);
            neighborMax = max(neighborMax, neighborYCoCg);
        }
    }

    // Variance Clipping : https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf
    const float gamma = 1.0; // tightness of the clipping
    vec3 mu    = m1 / 9.0;
    vec3 sigma = sqrt(abs(m2 / 9.0 - mu * mu));
    vec3 minc  = mu - gamma * sigma;
    vec3 maxc  = mu + gamma * sigma;

    vec3 clampedHistoryYCoCg = ClipAABB(minc, maxc, historyYCoCg, currentYCoCg);
    vec3 clampedHistory      = YCoCg2RGB(clampedHistoryYCoCg);

    // velocity-based weight adjustment
    float velocityMagnitude = length(velocity * texSize);
    float velocityWeight    = 1.0 / (1.0 + velocityMagnitude * 0.1);

    float blendAlpha = bValidHistory ? g_Push.blendFactor * velocityWeight : 1.0;

    vec3 finalColor = mix(clampedHistory, currentColor, blendAlpha);

    imageStore(g_OutputImage, pixelCoord, vec4(finalColor, 1.0));
}