#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_gpu_shader_int64 : enable

#define _CAMERA
#include "Common.hg"
#define _ATMOSPHERE
#include "AtmosphereCommon.hg"
#include "HelperFunctions.hg"

layout(set = SET_PUSH, binding = 2) uniform CloudData
{
    float coverage;
    float cloudType;
    float precipitation;
    float padding0;

    float topLayer_km;
    float bottomLayer_km;
    vec2  padding1;

    float baseNoiseScale;
    float baseNoiseIntensity;
    float detailNoiseScale;
    float detailNoiseIntensity;

    vec3  windDirection;
    float windSpeed_mps;
} g_Cloud;

layout(set = SET_PUSH, binding = 3)  uniform sampler3D g_CloudBaseNoise;
layout(set = SET_PUSH, binding = 4)  uniform sampler3D g_CloudDetailNoise;
layout(set = SET_PUSH, binding = 5)  uniform sampler2D g_VerticalProfileLUT;
layout(set = SET_PUSH, binding = 6)  uniform sampler2D g_WeatherMap;
layout(set = SET_PUSH, binding = 7)  uniform sampler2D g_CurlNoise;
layout(set = SET_PUSH, binding = 8)  uniform sampler2D g_BlueNoise;
layout(set = SET_PUSH, binding = 9)  uniform sampler2D g_DepthBuffer;
layout(set = SET_PUSH, binding = 10) uniform sampler2D g_TransmittanceLUT;
layout(set = SET_PUSH, binding = 11) uniform sampler2D g_MultiScatteringLUT;

layout(set = SET_PUSH, binding = 12, rgba16f) writeonly uniform image2D g_CloudScatteringLUT;

layout(push_constant) uniform Push 
{
    float    time_s;
    uint64_t frame;
} g_Push;

// Reference: https://www.shadertoy.com/view/ttcSD8
const float CLOUD_DENSITY_SCALE = 0.5;
const float CLOUD_ABSORPTION = 0.9;
const float CLOUD_SCATTERING = 1.0;
const float CLOUD_FORWARD_SCATTERING_G = 0.8;  // Henyey-Greenstein phase function parameter
const float CLOUD_BACKWARD_SCATTERING_G = -0.2;
const float CLOUD_FORWARD_SCATTERING_BLEND = 0.5;

const float CLOUD_TOP_OFFSET = 0.025;
const float CLOUD_ABSORPTION_TOP = 1.8;
const float CLOUD_ABSORPTION_BOTTOM = 3.6;

const uint  CLOUD_RAYMARCH_STEPS = 128;
const uint  CLOUD_SHADOW_RAYMARCH_STEPS = 12;
#define CLOUDS_DETAIL_STRENGTH (.225)
#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))
#define CLOUDS_AMBIENT_COLOR_BOTTOM (vec3(39., 67., 87.)*(1.5/255.))


#define STRATUS_GRADIENT vec4(0.0, 0.1, 0.2, 0.3)
#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)
#define CUMULUS_GRADIENT vec4(0.00, 0.1625, 0.88, 0.98)

const int BAYER_LIMIT = 16;
const int BAYER_LIMIT_H = 4;
const int BAYER_FILTER[BAYER_LIMIT] = int[]
(
     0,  8,  2, 10,
    12,  4, 14,  6,
     3, 11,  1,  9,
    15,  7, 13,  5
);

const vec3 RANDOM_KERNEL[6u] = vec3[]
(
    vec3( 0.38051305,  0.92453449, -0.02111345),
    vec3(-0.50625799, -0.03590792, -0.86163418),
    vec3(-0.32509218, -0.94557439,  0.01428793),
    vec3( 0.09026238, -0.27376545,  0.95755165),
    vec3( 0.28128598,  0.42443639, -0.86065785),
    vec3(-0.16852403,  0.14748697,  0.97460106)
);

float phase_HG(float cosTheta, float g)
{
    float g2    = g * g;
    float num   = 1.0 - g2;
    float denom = 4.0 * PI * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);

    return num / denom;
}

float PowderEffect(float depth, float height, float VoL)
{
    float r = -abs(VoL) * 0.5 + 0.5;
    r = r * r;

    height = height * (1.0 - r) + r;
    return depth * height;
}

float GetCloudCoverage(vec3 pos, float normalizeHeight)
{
    const vec3 windOffset = vec3(0) ;//(frameData.appTime.x) * vec3(1.0);

    // Offset 5km.
    vec2 weatherUV    = (pos.xz + vec2(5.0, 5.0) + windOffset.xy) * 0.3 * 0.03 * 1.0;
    vec4 weatherValue = texture(g_WeatherMap, weatherUV);

    vec2 gradientUV    = vec2(pow(weatherValue.g, 0.5), clamp(1.0 - normalizeHeight, 0.01, 0.99));
    vec4 gradientValue = texture(g_VerticalProfileLUT, gradientUV);

    return weatherValue.r * gradientValue.r;
}

float GetCloudBaseShape(vec3 pos)
{
    vec3  baseUVW   = pos * g_Cloud.baseNoiseScale;
    vec4  baseNoise = texture(g_CloudBaseNoise, baseUVW);
    // float baseCloud = saturate(remap(baseNoise.r, dot(baseNoise.gba, vec3(0.625, 0.25, 0.125)) - 1.0, 1.0, 0.0, 1.0));
    float baseCloud = baseNoise.r;

    return baseCloud;
}

float GetCloudDetailShape(vec3 pos, float hNorm)
{
    vec3  detailUVW   = pos * g_Cloud.detailNoiseScale;
    vec3  detailNoise = texture(g_CloudDetailNoise, detailUVW).rgb;
    float detailShape = dot(detailNoise, vec3(0.625, 0.25, 0.125));
          detailShape = mix(detailShape, 1.0 - detailShape, saturate(hNorm * 10.0));

    return detailShape;
}

float SampleCloudDensity(vec3 pos, float hNorm)
{
    // vec3 windOffset = g_Push.time_s * g_Cloud.windSpeed_mps * 0.001;
    //pos.xz -= g_Cloud.windDirection.xz * hNorm * CLOUD_TOP_OFFSET;
    pos.y -= g_Atmosphere.planetRadius_km;
    pos   += g_Cloud.windDirection * hNorm * 0.5;

    float verticalProfile    = texture(g_VerticalProfileLUT, vec2(g_Cloud.cloudType, hNorm)).r;
    float dimensionalProfile = verticalProfile * g_Cloud.coverage;

    vec4 weatherValue;
    {
        vec2 weatherUV    = pos.xz * 0.02;
             weatherValue = texture(g_WeatherMap, weatherUV);
    }

    float base;
    {
        vec3 baseUVW  = pos;
             baseUVW *= g_Cloud.baseNoiseScale;

        base = texture(g_CloudBaseNoise, baseUVW).r;
    }

    if (base > 0.0)
    {
        float detail = GetCloudDetailShape(pos, hNorm);

        //base = remap(base, detail * 0.19, 1.0, 0.0, 1.0);
        // base = inverseLerp(base, detail * 0.5, 1.0);
    }

    //float shape = pow(base, remap(hNorm, 0.6, 0.8, 1.0, mix(1.0, 0.1, 0.5)));

    return saturate(base);
}

float RaymarchLight(vec3 rayOrigin, vec3 rayDirection)
{
    float shadowMarchLength = 15.0;
    float numShadowStepsInv = 1.0 / CLOUD_SHADOW_RAYMARCH_STEPS;

    float shadow = 0.0;
	for(float st = numShadowStepsInv; st <= 1.00001; st += numShadowStepsInv)
	{
        float t    = st * st;
        vec3  spos = rayOrigin + t * rayDirection;

        float saltitude = length(spos) - g_Atmosphere.planetRadius_km;
        float shNorm    = inverseLerp(saltitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);

		shadow += max(0, SampleCloudDensity(rayOrigin, shNorm) * t);
	}

	return exp(-shadow);
}

vec4 RaymarchClouds(vec3 rayOrigin, vec3 rayDir, float maxDistance)
{
    float rBottomLayer = g_Atmosphere.planetRadius_km + g_Cloud.bottomLayer_km;
    float rTopLayer    = g_Atmosphere.planetRadius_km + g_Cloud.topLayer_km;
    
    vec2 bottomIntersection = 
        RaySphereIntersection(rayOrigin, rayDir, PLANET_CENTER, rBottomLayer);
    vec2 topIntersection    = 
        RaySphereIntersection(rayOrigin, rayDir, PLANET_CENTER, rTopLayer);

    float rayStart = bottomIntersection.y > 0.0 ? bottomIntersection.y : 0.0;
    float rayEnd   = topIntersection.y;

    if (length(rayOrigin) >= rBottomLayer && length(rayOrigin) <= rTopLayer)
    {
        // camera in-between cloud layers
        rayStart = 0.0;
        rayEnd   = topIntersection.y > 0.0 ? min(topIntersection.y, maxDistance) : maxDistance;
    }
    else if (bottomIntersection.y > 0.0)
    {
        // camera in-below cloud bottom layer
        rayStart = min(bottomIntersection.y, maxDistance);
        rayEnd   = min(topIntersection.y, maxDistance);
    }
    else if (topIntersection.x > 0.0 && topIntersection.x < maxDistance)
    {
        // camera in-above cloud top layer
        rayStart = topIntersection.x;
        rayEnd   = min(bottomIntersection.y, maxDistance);
    }
    else
    {
        // no cloud intersection
        return vec4(0.0, 0.0, 0.0, 1.0);
    }
    
    float rayLength = rayEnd - rayStart;
    if (rayLength <= 0.0)
        return vec4(0.0, 0.0, 0.0, 1.0);
    
    // light illuminance
    vec3 lightColor = vec3(g_Atmosphere.light.colorR, g_Atmosphere.light.colorG, g_Atmosphere.light.colorB);
    if (g_Atmosphere.light.temperature_K > 0.0)
        lightColor *= ColorTemperatureToRGB(g_Atmosphere.light.temperature_K);

    vec3 E      = g_Atmosphere.light.illuminance_lux * lightColor;
    vec3 sunDir = normalize(vec3(-g_Atmosphere.light.dirX, -g_Atmosphere.light.dirY, -g_Atmosphere.light.dirZ));

    // phase function
    float cosTheta      = dot(rayDir, sunDir);
    float forwardPhase  = phase_HG(cosTheta, CLOUD_FORWARD_SCATTERING_G);
    float backwardPhase = phase_HG(cosTheta, CLOUD_BACKWARD_SCATTERING_G);
    float phase         = mix(forwardPhase, backwardPhase, CLOUD_FORWARD_SCATTERING_BLEND);

    float stepSize = rayLength / float(CLOUD_RAYMARCH_STEPS);
    float tSample  = rayStart + 0.001 * stepSize;
    
    vec3  L          = vec3(0.0);
    float throughput = 1.0;
    for (uint i = 0u; i < CLOUD_RAYMARCH_STEPS; ++i)
    {
        vec3  pos = rayOrigin + tSample * rayDir;

        float sampleTheta          = dot(normalize(pos), sunDir);
        float sampleHeight         = length(pos);
        vec3  transmittanceToLight = SampleTransmittanceLUT(g_TransmittanceLUT, sampleHeight, sampleTheta, g_Atmosphere.planetRadius_km, g_Atmosphere.atmosphereRadius_km);
        
        // Sample cloud density with LOD based on distance
        float altitude    = sampleHeight - g_Atmosphere.planetRadius_km;
        float hNorm       = inverseLerp(altitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);
        //float lod      = smoothstep(0.0, 100.0, t * 0.1);
        float stepDensity = SampleCloudDensity(pos, hNorm);
        if (stepDensity > 0.0)
        {
            float opticalDepth      = stepDensity * stepSize * 1000.0; // to meter unit
            float stepTransmittance = max(exp(-opticalDepth), exp(-opticalDepth * 0.25) * 0.7);

            float shadow = RaymarchLight(pos, sunDir);

            // float d      = pow(clamp(stepDensity * 8.0, 0.0, 1.0), remap(hNorm, 0.3, 0.85, 0.5, 2.0)) + 0.05;
            // float v      = pow(remap(hNorm, 0.07, 0.22, 0.1, 1.0), 0.8);
            // float powder = PowderEffect(d, v, sampleTheta);

            vec3 ambientLight = mix(CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, hNorm);

            vec3 S      = (ambientLight + E * transmittanceToLight * phase) * stepDensity;
            vec3 Sint   = (S - S * stepTransmittance) / stepDensity;
            L          += throughput * Sint;
            throughput *= stepTransmittance;
        }
    }

    return vec4(L, throughput);
}

#define MAX_STEPS 100
#define MAX_STEPS_LIGHTS 6
const float MARCH_SIZE = 0.08;
const float ABSORPTION_COEFFICIENT = 0.1;

float sdSphere(vec3 p, float radius) 
{
    return length(p) - radius;
}

float sdHollowSphere(vec3 p, vec3 center, float innerRadius, float outerRadius)
{
    float dist = length(p - center);
    
    float outerDist = dist - outerRadius;
    float innerDist = innerRadius - dist;
    
    // For a hollow sphere:
    // - If outside outer sphere: distance to outer surface (positive)
    // - If inside inner sphere: distance to inner surface (positive) 
    // - If between radii (in shell): negative of minimum distance to either surface
    return max(outerDist, innerDist);
}

float scene(vec3 p, float hNorm) 
{
    p   -= g_Cloud.windDirection * g_Push.time_s * g_Cloud.windSpeed_mps;

    float verticalProfile    = texture(g_VerticalProfileLUT, vec2(g_Cloud.cloudType, hNorm)).r;

    float f = GetCloudBaseShape(p * 1e3);
    f = remap(f * verticalProfile, 1.0 - g_Cloud.coverage, 1.0, 0.0, 1.0);

    if (f > 0.0)
    {
        //float d = GetCloudDetailShape(p * 10000.0, hNorm);
        //f = remap(f, 1.0 - d, 1.0, 0.0, 1.0);
    }

    return f;
}

float BeersLaw(float d, float a) 
{
    return exp(-d * a);
}

vec3 raymarchTest(vec3 rayOrigin, vec3 rayDirection, float offset, float maxDistance)
{
    float rBottomLayer = g_Atmosphere.planetRadius_km + g_Cloud.bottomLayer_km;
    float rTopLayer    = g_Atmosphere.planetRadius_km + g_Cloud.topLayer_km;
    
    vec2 bottomIntersection = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rBottomLayer);
    vec2 topIntersection    = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rTopLayer);

    float rayStart = bottomIntersection.y > 0.0 ? bottomIntersection.y : 0.0;
    float rayEnd   = topIntersection.y;

    if (length(rayOrigin) >= rBottomLayer && length(rayOrigin) <= rTopLayer)
    {
        // camera in-between cloud layers
        rayStart = 0.0;
        rayEnd   = topIntersection.y > 0.0 ? min(topIntersection.y, maxDistance) : maxDistance;
    }
    else if (bottomIntersection.y > 0.0)
    {
        // camera in-below cloud bottom layer
        rayStart = min(bottomIntersection.y, maxDistance);
        rayEnd   = min(topIntersection.y, maxDistance);
    }
    else if (topIntersection.x > 0.0 && topIntersection.x < maxDistance)
    {
        // camera in-above cloud top layer
        rayStart = topIntersection.x;
        rayEnd   = min(bottomIntersection.y, maxDistance);
    }
    else
    {
        // no cloud intersection
        return vec3(0.0, 0.0, 0.0);
    }
    
    float rayLength = rayEnd - rayStart;
    if (rayLength <= 0.0)
        return vec3(0.0, 0.0, 0.0);

    vec3 sunDirection = normalize(vec3(-g_Atmosphere.light.dirX, -g_Atmosphere.light.dirY, -g_Atmosphere.light.dirZ));
    vec3 lightColor = vec3(g_Atmosphere.light.colorR, g_Atmosphere.light.colorG, g_Atmosphere.light.colorB);
    if (g_Atmosphere.light.temperature_K > 0.0)
        lightColor *= ColorTemperatureToRGB(g_Atmosphere.light.temperature_K);

    vec3 E      = g_Atmosphere.light.illuminance_lux * lightColor;


    // phase function
    float cosTheta      = dot(rayDirection, sunDirection);
    float forwardPhase  = phase_HG(cosTheta, CLOUD_FORWARD_SCATTERING_G);
    float backwardPhase = phase_HG(cosTheta, CLOUD_BACKWARD_SCATTERING_G);
    float phase         = mix(forwardPhase, backwardPhase, CLOUD_FORWARD_SCATTERING_BLEND);

    float stepSize = rayLength / float(CLOUD_RAYMARCH_STEPS);
    float tSample  = rayStart + 0.5 * stepSize * offset;

    vec3 L = vec3(0.0);
    float throughput = 1.0;
    for (int i = 0; i < CLOUD_RAYMARCH_STEPS; i++) 
    {
        vec3  pos = rayOrigin + tSample * rayDirection;

        float sampleTheta          = dot(normalize(pos), sunDirection);
        float sampleHeight         = length(pos);
        vec3  transmittanceToLight = SampleTransmittanceLUT(g_TransmittanceLUT, sampleHeight, sampleTheta, g_Atmosphere.planetRadius_km, g_Atmosphere.atmosphereRadius_km);

        float altitude = sampleHeight - g_Atmosphere.planetRadius_km;
        float hNorm = inverseLerp(altitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);

        float stepDensity = scene(pos, hNorm);

        // We only draw the density if it's greater than 0
        if (stepDensity > 0.0) 
        {
            float opticalDepth      = stepDensity * stepSize * 5.0; // to meter unit
            // float stepTransmittance = max(exp(-opticalDepth), exp(-opticalDepth * 0.25) * 0.7);
            float stepTransmittance = exp(-opticalDepth);

            float shadow = RaymarchLight(pos, sunDirection);

            //float d      = pow(clamp(stepDensity * 8.0, 0.0, 1.0), remap(hNorm, 0.3, 0.85, 0.5, 2.0)) + 0.05;
            //float v      = pow(remap(hNorm, 0.07, 0.22, 0.1, 1.0), 0.8);
            //float powder = PowderEffect(d, v, sampleTheta);

            vec3 ambientLit = (1.0 - sunDirection.y * sunDirection.y) * mix(transmittanceToLight, vec3(1.0), saturate(1.0 - throughput));

            vec3 S      = (ambientLit + E * transmittanceToLight * phase) * stepDensity;
            vec3 Sint   = (S - S * stepTransmittance) / max(stepDensity, EPSILON);
            L          += throughput * stepTransmittance;
            throughput *= stepTransmittance;
        }

        if(throughput <= 1e-3)
        {
            break;
        }

        tSample += stepSize;
    }

    return L;
}

vec3 ACESFilm(vec3 x)
{
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;

    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}


layout (local_size_x = 8, local_size_y = 8) in;
void main()
{
    ivec2 imgSize   = imageSize(g_CloudScatteringLUT);
    ivec2 pixCoords = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;

    vec2  uv        = (vec2(pixCoords) + 0.5) / vec2(imgSize);
    float depth     = texture(g_DepthBuffer, uv).r;

    vec3 cameraPos            = g_Camera.posWORLD * DISTANCE_SCALE;
    vec3 cameraPosAbovePlanet = cameraPos + vec3(0.0, g_Atmosphere.planetRadius_km, 0.0);

    vec3 posWORLD     = ReconstructWorldPos(uv, depth, g_Camera.mViewProjInv);
    vec3 rayDirection = normalize(posWORLD);
    vec3 rayOrigin    = cameraPosAbovePlanet;

    vec2  groundIntersection = RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, g_Atmosphere.planetRadius_km);
    float maxDistance        = groundIntersection.x > 0.0 ? groundIntersection.x : groundIntersection.y > 0.0 ? groundIntersection.y : RAY_MARCHING_MAX_DISTANCE;
          maxDistance        = min(maxDistance, depth == 1.0 ? RAY_MARCHING_MAX_DISTANCE : posWORLD.z * DISTANCE_SCALE);
    
    vec2 blueNoiseSize = textureSize(g_BlueNoise, 0);
    float blueNoise = texture(g_BlueNoise, pixCoords / blueNoiseSize).r;
    float offset = fract(blueNoise + float(g_Push.frame % 32) / sqrt(0.5));

    vec3 clouds = raymarchTest(rayOrigin, rayDirection, offset, maxDistance); //RaymarchClouds(rayOrigin, rayDirection, maxDistance);

    imageStore(g_CloudScatteringLUT, pixCoords, vec4(clouds, 1.0));


    ///////////////////////////////////////////////////////////////////////
    // vec3 ro = cameraPosAbovePlanet;
    // vec3 rd = rayDirection;
    // 
    // vec2 blueNoiseSize = textureSize(g_BlueNoise, 0);
    // float blueNoise = texture(g_BlueNoise, pixCoords / blueNoiseSize).r;
    // float offset = fract(blueNoise + float(g_Push.frame % 32) / sqrt(0.5));
    // 
    // clouds = vec4(ACESFilm(raymarchTest(ro, rd, offset, maxDistance)), 1.0);
    // 
    // imageStore(g_CloudScatteringLUT, pixCoords, clouds);
}