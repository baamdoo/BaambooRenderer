#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_gpu_shader_int64 : enable

#define _CAMERA
#include "Common.hg"
#define _ATMOSPHERE
#include "AtmosphereCommon.hg"
#include "HelperFunctions.hg"
#include "Noise.hg"

layout(set = SET_PUSH, binding = 2) uniform CloudData
{
    float coverage;
    float cloudType;
    float precipitation;
    float padding0;

    float topLayer_km;
    float bottomLayer_km;
    vec2  padding1;

    float baseNoiseScale;
    float baseIntensity;
    float detailNoiseScale;
    float detailIntensity;

    vec3  windDirection;
    float windSpeed_mps;
} g_Cloud;

layout(set = SET_PUSH, binding = 3)  uniform sampler3D g_CloudBaseNoise;
layout(set = SET_PUSH, binding = 4)  uniform sampler3D g_CloudDetailNoise;
layout(set = SET_PUSH, binding = 5)  uniform sampler2D g_VerticalProfileLUT;
layout(set = SET_PUSH, binding = 6)  uniform sampler2D g_WeatherMap;
layout(set = SET_PUSH, binding = 7)  uniform sampler2D g_CurlNoise;
layout(set = SET_PUSH, binding = 8)  uniform sampler2D g_BlueNoise;
layout(set = SET_PUSH, binding = 9)  uniform sampler2D g_DepthBuffer;
layout(set = SET_PUSH, binding = 10) uniform sampler2D g_TransmittanceLUT;
layout(set = SET_PUSH, binding = 11) uniform sampler2D g_MultiScatteringLUT;

layout(set = SET_PUSH, binding = 12, rgba16f) writeonly uniform image2D g_CloudScatteringLUT;

layout(push_constant) uniform Push 
{
    float    time_s;
    uint64_t frame;
} g_Push;

// Reference: https://www.shadertoy.com/view/ttcSD8
const float CLOUD_DENSITY_SCALE = 0.5;
const float CLOUD_ABSORPTION = 0.9;
const float CLOUD_SCATTERING = 1.0;
const float CLOUD_FORWARD_SCATTERING_G = 0.8;  // Henyey-Greenstein phase function parameter
const float CLOUD_BACKWARD_SCATTERING_G = -0.2;
const float CLOUD_FORWARD_SCATTERING_BLEND = 0.5;

const float CLOUD_TOP_OFFSET = 0.025;
const float CLOUD_ABSORPTION_TOP = 1.8;
const float CLOUD_ABSORPTION_BOTTOM = 3.6;

const uint  CLOUD_RAYMARCH_STEPS = 128;
const uint  CLOUD_SHADOW_RAYMARCH_STEPS = 12;
#define CLOUDS_DETAIL_STRENGTH (.225)
#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))
#define CLOUDS_AMBIENT_COLOR_BOTTOM (vec3(39., 67., 87.)*(1.5/255.))


#define STRATUS_GRADIENT vec4(0.0, 0.1, 0.2, 0.3)
#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)
#define CUMULUS_GRADIENT vec4(0.00, 0.1625, 0.88, 0.98)

const int BAYER_LIMIT = 16;
const int BAYER_LIMIT_H = 4;
const int BAYER_FILTER[BAYER_LIMIT] = int[]
(
     0,  8,  2, 10,
    12,  4, 14,  6,
     3, 11,  1,  9,
    15,  7, 13,  5
);

const vec3 RANDOM_KERNEL[6u] = vec3[]
(
    vec3( 0.38051305,  0.92453449, -0.02111345),
    vec3(-0.50625799, -0.03590792, -0.86163418),
    vec3(-0.32509218, -0.94557439,  0.01428793),
    vec3( 0.09026238, -0.27376545,  0.95755165),
    vec3( 0.28128598,  0.42443639, -0.86065785),
    vec3(-0.16852403,  0.14748697,  0.97460106)
);

float phase_HG(float cosTheta, float g)
{
    float g2    = g * g;
    float num   = 1.0 - g2;
    float denom = 4.0 * PI * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);

    return num / denom;
}

float PowderEffect(float depth, float height, float VoL)
{
    float r = -abs(VoL) * 0.5 + 0.5;
    r = r * r;

    height = height * (1.0 - r) + r;
    return depth * height;
}

float GetCloudCoverage(vec3 pos, float normalizeHeight)
{
    const vec3 windOffset = vec3(0) ;//(frameData.appTime.x) * vec3(1.0);

    // Offset 5km.
    vec2 weatherUV    = (pos.xz + vec2(5.0, 5.0) + windOffset.xy) * 0.3 * 0.03 * 1.0;
    vec4 weatherValue = texture(g_WeatherMap, weatherUV);

    vec2 gradientUV    = vec2(pow(weatherValue.g, 0.5), clamp(1.0 - normalizeHeight, 0.01, 0.99));
    vec4 gradientValue = texture(g_VerticalProfileLUT, gradientUV);

    return weatherValue.r * gradientValue.r;
}

float GetCloudBaseShape(vec3 pos)
{
    vec3  baseUVW   = pos * g_Cloud.baseNoiseScale;
    vec4  baseNoise = texture(g_CloudBaseNoise, baseUVW);
    float baseCloud = saturate(remap(baseNoise.r, dot(baseNoise.gba, vec3(0.625, 0.125, 0.25)) - 1.0, 1.0, 0.0, 1.0));

    return baseCloud;
}

float GetCloudDetailShape(vec3 pos, float hNorm)
{
    vec3  detailUVW   = pos * g_Cloud.detailNoiseScale;
    vec3  detailNoise = texture(g_CloudDetailNoise, detailUVW).rgb;
    float detailShape = dot(detailNoise, vec3(0.625, 0.25, 0.125));
          detailShape = g_Cloud.detailIntensity * mix(detailShape, 1.0 - detailShape, saturate(hNorm * 10.0));

    return detailShape;
}

float SampleCloudDensity(vec3 pos, float hNorm)
{
    pos -= g_Cloud.windDirection * g_Push.time_s * g_Cloud.windSpeed_mps;
    
    float verticalProfile = texture(g_VerticalProfileLUT, vec2(g_Cloud.cloudType, hNorm)).r;

    float f  = GetCloudBaseShape(pos);
          f  = g_Cloud.coverage * safeRemap(f, 1.0 - g_Cloud.coverage, 1.0, 0.0, 1.0);
          f *= verticalProfile;

    if (f > 0.0)
    {
        float d = GetCloudDetailShape(pos, hNorm);

        f = remap(f, d, 1.0, 0.0, 1.0);
    }

    f = pow(f, saturate(1.0 - hNorm) * 0.4 + 0.1) * g_Cloud.baseIntensity;

    return f;
}

float RaymarchLight(vec3 rayOrigin, vec3 rayDirection)
{
    float rTopLayer      = g_Atmosphere.planetRadius_km + g_Cloud.topLayer_km;
    vec2 topIntersection = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rTopLayer);
    if (all(lessThan(topIntersection, vec2(0.0, 0.0))))
    {
        return 1.0;
    }

    float shadowMarchLength   = topIntersection.x > 0.0 ? topIntersection.x : topIntersection.y;
    float marchShadowStepSize = shadowMarchLength / float(CLOUD_SHADOW_RAYMARCH_STEPS);

    float shadow = 0.0;
	for(float st = marchShadowStepSize; st <= shadowMarchLength + 0.001; st += marchShadowStepSize)
	{
        float t    = st;
        vec3  spos = rayOrigin + t * rayDirection;

        float saltitude = length(spos) - g_Atmosphere.planetRadius_km;
        float shNorm    = inverseLerp(saltitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);
        if (shNorm > 1.0)
        {
            return exp(-shadow);
        }

		shadow += max(0, SampleCloudDensity(spos, shNorm) * marchShadowStepSize);
	}

	return exp(-shadow);
}

vec4 RaymarchCloud(vec3 rayOrigin, vec3 rayDirection, float maxDistance)
{
    float rBottomLayer = g_Atmosphere.planetRadius_km + g_Cloud.bottomLayer_km;
    float rTopLayer    = g_Atmosphere.planetRadius_km + g_Cloud.topLayer_km;
    
    vec2 bottomIntersection = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rBottomLayer);
    vec2 topIntersection    = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rTopLayer);

    float rayStart = bottomIntersection.y > 0.0 ? bottomIntersection.y : 0.0;
    float rayEnd   = topIntersection.y;

    if (length(rayOrigin) >= rBottomLayer && length(rayOrigin) <= rTopLayer)
    {
        // camera in-between cloud layers
        rayStart = 0.0;
        rayEnd   = topIntersection.y > 0.0 ? min(topIntersection.y, maxDistance) : maxDistance;
    }
    else if (bottomIntersection.y > 0.0)
    {
        // camera in-below cloud bottom layer
        rayStart = min(bottomIntersection.y, maxDistance);
        rayEnd   = min(topIntersection.y, maxDistance);
    }
    else if (topIntersection.x > 0.0 && topIntersection.x < maxDistance)
    {
        // camera in-above cloud top layer
        rayStart = topIntersection.x;
        rayEnd   = min(bottomIntersection.y, maxDistance);
    }
    else
    {
        // no cloud intersection
        return vec4(0.0, 0.0, 0.0, 1.0);
    }
    
    float rayLength = rayEnd - rayStart;
    if (rayLength <= 0.0)
        return vec4(0.0, 0.0, 0.0, 1.0);

    vec3 sunDirection = normalize(vec3(-g_Atmosphere.light.dirX, -g_Atmosphere.light.dirY, -g_Atmosphere.light.dirZ));
    vec3 lightColor   = vec3(g_Atmosphere.light.colorR, g_Atmosphere.light.colorG, g_Atmosphere.light.colorB);
    if (g_Atmosphere.light.temperature_K > 0.0)
        lightColor *= ColorTemperatureToRGB(g_Atmosphere.light.temperature_K);

    vec3 E = g_Atmosphere.light.illuminance_lux * lightColor;


    // phase function
    float cosTheta      = dot(rayDirection, sunDirection);
    float forwardPhase  = phase_HG(cosTheta, CLOUD_FORWARD_SCATTERING_G);
    float backwardPhase = phase_HG(cosTheta, CLOUD_BACKWARD_SCATTERING_G);
    float phase         = mix(forwardPhase, backwardPhase, CLOUD_FORWARD_SCATTERING_BLEND);

    float stepSize = rayLength / float(CLOUD_RAYMARCH_STEPS);
    float tSample  = rayStart - stepSize * hash1D(rayDirection);

    vec3 L           = vec3(0.0);
    float throughput = 1.0;
    for (int i = 0; i < CLOUD_RAYMARCH_STEPS; i++) 
    {
        vec3  pos = rayOrigin + tSample * rayDirection;

        float sampleTheta          = dot(normalize(pos), sunDirection);
        float sampleHeight         = length(pos);
        vec3  transmittanceToLight = SampleTransmittanceLUT(g_TransmittanceLUT, sampleHeight, sampleTheta, g_Atmosphere.planetRadius_km, g_Atmosphere.atmosphereRadius_km);

        float altitude = sampleHeight - g_Atmosphere.planetRadius_km;
        float hNorm    = inverseLerp(altitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);

        float stepDensity = SampleCloudDensity(pos, hNorm);

        // We only draw the density if it's greater than 0
        if (stepDensity > 0.0) 
        {
            float opticalDepth      = stepDensity * stepSize;
            //float stepTransmittance = max(exp(-opticalDepth), exp(-opticalDepth * 0.25) * 0.7);
            float stepTransmittance = exp(-opticalDepth);

            float shadow = RaymarchLight(pos, sunDirection);

            float d      = pow(clamp(stepDensity * 8.0, 0.0, 1.0), safeRemap(hNorm, 0.3, 0.85, 0.5, 2.0)) + 0.05;
            float v      = pow(safeRemap(hNorm, 0.07, 0.22, 0.1, 1.0), 0.8);
            float powder = PowderEffect(d, v, sampleTheta);

            //vec3 ambientLit = (1.0 - sunDirection.y * sunDirection.y) * mix(transmittanceToLight, vec3(1.0), saturate(1.0 - throughput));
            vec3 ambientLit = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, hNorm );

            vec3 S      = (ambientLit + E * transmittanceToLight * shadow * powder) * stepDensity;
            vec3 Sint   = (S - S * stepTransmittance) / max(stepDensity, EPSILON);
            L          += throughput * Sint;
            throughput *= stepTransmittance;
        }

        if(throughput <= 1e-3)
        {
            break;
        }

        tSample += stepSize;
    }

    return vec4(L, throughput);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main()
{
    ivec2 imgSize   = imageSize(g_CloudScatteringLUT);
    ivec2 pixCoords = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;

    vec2  uv        = (vec2(pixCoords) + 0.5) / vec2(imgSize);
    float depth     = texture(g_DepthBuffer, uv).r;

    vec3 cameraPos =
            vec3(g_Camera.posWORLD.x, max(g_Camera.posWORLD.y, MIN_VIEW_HEIGHT_ABOVE_GROUND), g_Camera.posWORLD.z);
    vec3 cameraPosAbovePlanet = 
        cameraPos * DISTANCE_SCALE + vec3(0.0, g_Atmosphere.planetRadius_km, 0.0);

    vec3 posWORLD     = ReconstructWorldPos(uv, depth, g_Camera.mViewProjInv);
    vec3 rayDirection = normalize(posWORLD);
    vec3 rayOrigin    = cameraPosAbovePlanet;

    vec2  groundIntersection = RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, g_Atmosphere.planetRadius_km);
    float maxDistance        = groundIntersection.x > 0.0 ? groundIntersection.x : groundIntersection.y > 0.0 ? groundIntersection.y : RAY_MARCHING_MAX_DISTANCE;
          maxDistance        = min(maxDistance, depth == 1.0 ? RAY_MARCHING_MAX_DISTANCE : posWORLD.z * DISTANCE_SCALE);
    
    vec4 clouds = RaymarchCloud(rayOrigin, rayDirection, maxDistance);

    imageStore(g_CloudScatteringLUT, pixCoords, clouds);
}