#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_gpu_shader_int64 : enable

#define _CAMERA
#include "Common.hg"
#define _ATMOSPHERE
#include "AtmosphereCommon.hg"
#include "HelperFunctions.hg"
#include "Noise.hg"

layout(set = SET_PUSH, binding = 2) uniform CloudData
{
    float coverage;
    float cloudType;
    float precipitation;
    float padding0;

    float topLayer_km;
    float bottomLayer_km;
    vec2  padding1;

    float baseNoiseScale;
    float baseIntensity;
    float detailNoiseScale;
    float detailIntensity;

    vec3  windDirection;
    float windSpeed_mps;
} g_Cloud;

layout(set = SET_PUSH, binding = 3)  uniform sampler3D g_CloudBaseNoise;
layout(set = SET_PUSH, binding = 4)  uniform sampler3D g_CloudDetailNoise;
layout(set = SET_PUSH, binding = 5)  uniform sampler2D g_VerticalProfileLUT;
layout(set = SET_PUSH, binding = 6)  uniform sampler2D g_WeatherMap;
layout(set = SET_PUSH, binding = 7)  uniform sampler2D g_CurlNoise;
layout(set = SET_PUSH, binding = 8)  uniform sampler2D g_BlueNoise;
layout(set = SET_PUSH, binding = 9)  uniform sampler2D g_DepthBuffer;
layout(set = SET_PUSH, binding = 10) uniform sampler2D g_TransmittanceLUT;
layout(set = SET_PUSH, binding = 11) uniform sampler2D g_MultiScatteringLUT;

layout(set = SET_PUSH, binding = 12, rgba16f) writeonly uniform image2D g_CloudScatteringLUT;

layout(push_constant) uniform Push 
{
    float    time_s;
    uint64_t frame;
} g_Push;

const float CLOUD_FORWARD_SCATTERING_G = 0.8;  // Henyey-Greenstein phase function parameter
const float CLOUD_BACKWARD_SCATTERING_G = -0.2;
const float CLOUD_FORWARD_SCATTERING_BLEND = 0.5;
const vec3 EXTINCTION_MULTIPLIER = vec3(0.8, 0.8, 1.0);

const uint  CLOUD_RAYMARCH_STEPS = 128;
const uint  CLOUD_SHADOW_RAYMARCH_STEPS = 12;

float phase_HG(float cosTheta, float g)
{
    float g2    = g * g;
    float num   = 1.0 - g2;
    float denom = 4.0 * PI * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);

    return num / denom;
}

float phase_Draine(float cosTheta, float g, float a)
{
    float g2    = g * g;
    float num   = (1.0 - g2) * (1.0 + a * cosTheta * cosTheta);
    float denom = (1.0 + (a * (1.0 + 2.0 * g2)) / 3.0) * 4.0 * PI * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);

    return num / denom;
}

float PowderEffect(float depth, float height, float VoL)
{
    float r = -abs(VoL) * 0.5 + 0.5;
    r = r * r;

    height = height * (1.0 - r) + r;
    return depth * height;
}

float GetCloudCoverage(vec3 pos, float normalizeHeight)
{
    const vec3 windOffset = vec3(0) ;//(frameData.appTime.x) * vec3(1.0);

    // Offset 5km.
    vec2 weatherUV    = (pos.xz + vec2(5.0, 5.0) + windOffset.xy) * 0.3 * 0.03 * 1.0;
    vec4 weatherValue = texture(g_WeatherMap, weatherUV);

    vec2 gradientUV    = vec2(pow(weatherValue.g, 0.5), clamp(1.0 - normalizeHeight, 0.01, 0.99));
    vec4 gradientValue = texture(g_VerticalProfileLUT, gradientUV);

    return weatherValue.r * gradientValue.r;
}

float GetCloudBaseShape(vec3 pos)
{
    vec3  baseUVW   = pos * g_Cloud.baseNoiseScale;
    vec4  baseNoise = texture(g_CloudBaseNoise, baseUVW);
    float baseCloud = saturate(remap(baseNoise.r, dot(baseNoise.gba, vec3(0.625, 0.125, 0.25)) - 1.0, 1.0, 0.0, 1.0));

    return baseCloud;
}

float GetCloudDetailShape(vec3 pos, float hNorm)
{
    vec3  detailUVW   = pos * g_Cloud.detailNoiseScale;
    vec3  detailNoise = texture(g_CloudDetailNoise, detailUVW).rgb;
    float detailShape = dot(detailNoise, vec3(0.625, 0.25, 0.125));
          detailShape = g_Cloud.detailIntensity * mix(detailShape, 1.0 - detailShape, saturate(hNorm * 10.0));

    return detailShape;
}

float SampleCloudDensity(vec3 pos, float hNorm)
{
    if (hNorm < 0.0)
    {
        return 0.0;
    }

    pos -= g_Cloud.windDirection * g_Push.time_s * g_Cloud.windSpeed_mps;
    
    vec2  weatherUV = pos.xz * (1.0 / 100.0);

    float coverage           = texture(g_WeatherMap, weatherUV).r;
    float cloudType          = texture(g_WeatherMap, weatherUV).g;
    float verticalProfile    = texture(g_VerticalProfileLUT, vec2(g_Cloud.cloudType, hNorm)).r;
    float dimensionalProfile = verticalProfile * g_Cloud.coverage;

    float f = GetCloudBaseShape(pos);
          //f  = g_Cloud.coverage * safeRemap(f, 1.0 - g_Cloud.coverage, 1.0, 0.0, 1.0);
          //f *= verticalProfile;
          f = saturate(f - (1.0 - dimensionalProfile));

    if (f > 0.0)
    {
        float d = GetCloudDetailShape(pos, hNorm);

        f = safeRemap(f, d, 1.0, 0.0, 1.0);
    }

    // f = pow(f, saturate(1.0 - hNorm) * 0.4 + 0.1) * g_Cloud.baseIntensity;
    f *= g_Cloud.baseIntensity;

    return f;
}

// Reference: https://twitter.com/FewesW/status/1364629939568451587/photo/1
float MultipleOctaveScattering(float density, float cosTheta) 
{
    float attenuation      = 0.59;
    float contribution     = 0.84;
    float phaseAttenuation = 1.0;
    
    float a = attenuation;
    float b = contribution;
    float c = phaseAttenuation;
    const int scatteringOctaves = 8;
    
    float luminance = 0.0;
    for (int i = 0; i < scatteringOctaves; ++i) 
    {
        float forwardPhase = phase_HG(cosTheta, c * 0.9881);
        float drainePhase  = phase_Draine(cosTheta, 0.5567, 21.9955);
        float phase        = mix(forwardPhase, drainePhase, 0.4824);

        //float phase = phase_HG(c * 0.59, cosTheta);
        float beers = exp(-density * 0.424 * a);
        
        luminance += b * phase * beers;
        
        a *= attenuation;
        b *= contribution;
        // c *= (1.0 - phaseAttenuation);
    }

    return luminance;
}

vec3 RaymarchLight(vec3 rayOrigin, vec3 rayDirection, float VoL)
{
    float rTopLayer      = g_Atmosphere.planetRadius_km + g_Cloud.topLayer_km;
    vec2 topIntersection = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rTopLayer);
    if (all(lessThan(topIntersection, vec2(0.0, 0.0))))
    {
        return vec3(1.0);
    }

    float shadowMarchLength  = topIntersection.y;
    float invShadowStepCount = 1.0 / float(CLOUD_SHADOW_RAYMARCH_STEPS);
    // float marchShadowStepSize = shadowMarchLength / float(CLOUD_SHADOW_RAYMARCH_STEPS);

    float tPrev   = 0.0;
    float density = 0.0;
	for(float st = invShadowStepCount; st <= 1.0 + 0.001; st += invShadowStepCount)
	{
        float tCurr   = st * st;   // non-linear shadow sample distribution
        float tDelta  = tCurr - tPrev;
        float tShadow = shadowMarchLength * (tCurr - 0.5 * tDelta);

        vec3 spos = rayOrigin + tShadow * rayDirection;

        float saltitude = length(spos) - g_Atmosphere.planetRadius_km;
        float shNorm    = inverseLerp(saltitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);
        if (shNorm > 1.0)
        {
            break;
        }

		density += max(0, SampleCloudDensity(spos, shNorm) * shadowMarchLength * tDelta);

        tPrev = tCurr;
	}

    float beers  = exp(-density);
    //float beers  = MultipleOctaveScattering(density, VoL);
    //float powder = 1.0 - exp(-density * 2.0);

    //return vec3(1.0);
    //return powder;
	return vec3(beers);
	// return beers;// * 2.0 * powder;//mix(2.0 * powder, vec3(1.0), remap(VoL, -1.0, 1.0, 0.0, 1.0));
}

vec4 RaymarchCloud(vec3 rayOrigin, vec3 rayDirection, float maxDistance)
{
    float rBottomLayer = g_Atmosphere.planetRadius_km + g_Cloud.bottomLayer_km;
    float rTopLayer    = g_Atmosphere.planetRadius_km + g_Cloud.topLayer_km;
    
    vec2 bottomIntersection = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rBottomLayer);
    vec2 topIntersection    = 
        RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, rTopLayer);

    float rayStart = bottomIntersection.y > 0.0 ? bottomIntersection.y : 0.0;
    float rayEnd   = topIntersection.y;

    if (length(rayOrigin) >= rBottomLayer && length(rayOrigin) <= rTopLayer)
    {
        // camera in-between cloud layers
        rayStart = 0.0;
        rayEnd   = topIntersection.y > 0.0 ? min(topIntersection.y, maxDistance) : maxDistance;
    }
    else if (bottomIntersection.y > 0.0)
    {
        // camera in-below cloud bottom layer
        rayStart = min(bottomIntersection.y, maxDistance);
        rayEnd   = min(topIntersection.y, maxDistance);
    }
    else if (topIntersection.x > 0.0 && topIntersection.x < maxDistance)
    {
        // camera in-above cloud top layer
        rayStart = topIntersection.x;
        rayEnd   = min(bottomIntersection.y, maxDistance);
    }
    else
    {
        // no cloud intersection
        return vec4(0.0, 0.0, 0.0, 1.0);
    }
    
    float rayLength = rayEnd - rayStart;
    if (rayLength <= 0.0)
        return vec4(0.0, 0.0, 0.0, 1.0);

    vec3 sunDirection = normalize(vec3(-g_Atmosphere.light.dirX, -g_Atmosphere.light.dirY, -g_Atmosphere.light.dirZ));
    vec3 lightColor   = vec3(g_Atmosphere.light.colorR, g_Atmosphere.light.colorG, g_Atmosphere.light.colorB);
    if (g_Atmosphere.light.temperature_K > 0.0)
        lightColor *= ColorTemperatureToRGB(g_Atmosphere.light.temperature_K);

    vec3 E = g_Atmosphere.light.illuminance_lux * lightColor;


    // phase function
    float VoL           = dot(rayDirection, sunDirection);
    float forwardPhase  = phase_HG(VoL, 0.8);
    float backwardPhase = phase_HG(VoL, -0.5);
    float drainePhase   = phase_Draine(VoL, 0.69, 27.11369);
    //float phase         = mix(forwardPhase, backwardPhase, CLOUD_FORWARD_SCATTERING_BLEND);
    //float phase         = mix(forwardPhase, drainePhase, CLOUD_FORWARD_SCATTERING_BLEND);
    float phase = forwardPhase;

    float stepSize = rayLength / float(CLOUD_RAYMARCH_STEPS);
    float tSample  = rayStart - stepSize * hash1D(rayDirection);

    vec3 L           = vec3(0.0);
    float throughput = 1.0;
    for (int i = 0; i < CLOUD_RAYMARCH_STEPS; i++) 
    {
        vec3  pos = rayOrigin + tSample * rayDirection;

        float sampleTheta          = dot(normalize(pos), sunDirection);
        float sampleHeight         = length(pos);
        vec3  transmittanceToLight = SampleTransmittanceLUT(g_TransmittanceLUT, sampleHeight, sampleTheta, g_Atmosphere.planetRadius_km, g_Atmosphere.atmosphereRadius_km);

        float altitude = sampleHeight - g_Atmosphere.planetRadius_km;
        float hNorm    = inverseLerp(altitude, g_Cloud.bottomLayer_km, g_Cloud.topLayer_km);

        float stepDensity = SampleCloudDensity(pos, hNorm);
        if (stepDensity > EPSILON) 
        {
            float opticalDepth      = stepDensity * stepSize;
            //float stepTransmittance = max(exp(-opticalDepth), exp(-opticalDepth * 0.25) * 0.7);
            float stepTransmittance = exp(-opticalDepth);

            vec3 extinction = RaymarchLight(pos, sunDirection, VoL);

            float d      = pow(clamp(stepDensity * 8.0, 0.0, 1.0), safeRemap(hNorm, 0.3, 0.85, 0.5, 2.0)) + 0.05;
            float v      = pow(safeRemap(hNorm, 0.07, 0.22, 0.1, 1.0), 0.8);
            float powder = PowderEffect(d, v, sampleTheta);

            vec2 msUV = clamp(
                            vec2(sampleTheta * 0.5 + 0.5, inverseLerp(sampleHeight, g_Atmosphere.planetRadius_km, g_Atmosphere.atmosphereRadius_km)),
                        0.0, 1.0);
            vec3 multiScattering  = texture(g_MultiScatteringLUT, msUV).rgb;

            vec3 ambientLit = multiScattering * pow(1.0 - hNorm, 0.5);

            vec3 S      = (ambientLit + E * transmittanceToLight * extinction) * stepDensity;
            vec3 Sint   = (S - S * stepTransmittance) / max(stepDensity, EPSILON);
            L          += throughput * Sint;
            throughput *= stepTransmittance;
        }

        if(throughput <= 1e-3)
        {
            break;
        }

        tSample += stepSize;
    }

    return vec4(L, throughput);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main()
{
    ivec2 imgSize   = imageSize(g_CloudScatteringLUT);
    ivec2 pixCoords = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixCoords, imgSize)))
        return;

    vec2  uv        = (vec2(pixCoords) + 0.5) / vec2(imgSize);
    float depth     = texture(g_DepthBuffer, uv).r;

    vec3 cameraPos =
            vec3(g_Camera.posWORLD.x, max(g_Camera.posWORLD.y, MIN_VIEW_HEIGHT_ABOVE_GROUND), g_Camera.posWORLD.z);
    vec3 cameraPosAbovePlanet = 
        cameraPos * DISTANCE_SCALE + vec3(0.0, g_Atmosphere.planetRadius_km, 0.0);

    vec3 posWORLD     = ReconstructWorldPos(uv, depth, g_Camera.mViewProjInv);
    vec3 rayDirection = normalize(posWORLD - g_Camera.posWORLD);
    vec3 rayOrigin    = cameraPosAbovePlanet;

    vec2  groundIntersection = RaySphereIntersection(rayOrigin, rayDirection, PLANET_CENTER, g_Atmosphere.planetRadius_km);
    float maxDistance        = groundIntersection.x > 0.0 ? groundIntersection.x : groundIntersection.y > 0.0 ? groundIntersection.y : RAY_MARCHING_MAX_DISTANCE;
          maxDistance        = min(maxDistance, depth == 1.0 ? RAY_MARCHING_MAX_DISTANCE : length(posWORLD - g_Camera.posWORLD) * DISTANCE_SCALE);
    
    vec4 clouds = RaymarchCloud(rayOrigin, rayDirection, maxDistance);

    imageStore(g_CloudScatteringLUT, pixCoords, clouds);
}